<?php/* #  AUTHOR       : ELIZAR M. FLORES #  CLASSNAME    : QUERY #  DESCRIPTION  : PDO BASED DYNAMIC SQL QUERY FUNCTIONS #  VERSION      : 2.0 #  INITIALIZE   : INCLUDE FILE IN YOUR CLASSES OR LIBRARIES FOLDER AND FILL IN THE CONNECTION DETAILS AND YOU'RE GOOD TO GO (PDO CONNECTION).  #                 AS AN EXTENSION FOR CODEIGNITER OR OTHER MVCs, PLACE THE FILE ON THE [LIBRARIES] DIRECTORY.  #  USAGE        : REFER TO DOCUMENTTATION AT www.elizarflores.com * 	 */####CONNECTION DETAILS: INITIAL DATABASE CONFIGURATION ######################################################################################## defined('DB_SERVER') ? null : define("DB_SERVER", DB_HOST); defined('DB_USER')   ? null : define("DB_USER"  , DB_USER); defined('DB_PASS')   ? null : define("DB_PASS"  , DB_PASSWORD); defined('DB_NAME')   ? null : define("DB_NAME"  , DB_NAME);###############################################################################################################################################class QUERY{		# DATABASE REQUIRED VARIABLES	private $dbh;			    private $_conn; 		# THIS WILL BE THE FETCHED TABLE'S MAIN COLUMNS. IT CAN BE SET DYNAMICALLY WHEN AN INSTANCE IS CREATED	private $_columns = array();   		# RESULT OF THE FETCH 	protected $_result = array(); 		# TABLE NAMES        private $_table_raw; // HOLDS INITIAL TABLE DECLARATION        private $_table;         # JOIN CLAUSE        private $_join;        # QUERY KEYS 	private $_key;		# QUERY COLUMNS TO RETURN	private $_cols;                # QUERY GROUP BY        private $_group;        # QUERY ORDERS	private $_order;		# QUERY LIMIT	private $_limit;		# STRING AND KEY MODIFIER	private $_modifier = '37124RF70R35';    	# SUB CLAUSE 	private $_sub;		# FORMAT COLUMN HOLDER	private $_format;	 	# QUERY STRING HOLDER	private $_query_string = false;                # FETCH VARIABLE        public $fetch =  array();        public function __construct($assets = array())	 {			 #  CREATE THE CONNECTION TO THE DATABASE 		 $this->_conn = $this->dbh = new PDO('mysql:host=' . DB_SERVER . ';dbname='. DB_NAME, DB_USER, DB_PASS);		 $this->dbh->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);		 		 if(!empty($assets)):		  $this->_table_raw  = array_key_exists('TABLE' ,$assets)   ? $assets['TABLE']   : false; # VALUE                  $this->_join       = array_key_exists('JOIN', $assets)    ? $assets['JOIN']    : false; # MULTI DIMENSIONAL ARRAY  		  $this->_cols       = array_key_exists('COLS'  ,$assets)   ? $assets['COLS']    : false; # CAN BE AN ARRAY OR A VALUE		  $this->_key        = array_key_exists('KEY'   ,$assets)   ? $assets['KEY']     : false; # ARRAY		  $this->_sub        = array_key_exists('SUB_KEY' ,$assets) ? $assets['SUB_KEY'] : false; # STRING - DEPRECATED                  $this->_group      = array_key_exists('GROUP' ,$assets)   ? $assets['GROUP']   : false; # STRING                  $this->_order      = array_key_exists('ORDER' ,$assets)   ? $assets['ORDER']   : false; # STRING		  $this->_limit      = array_key_exists('LIMIT', $assets)   ? $assets['LIMIT']   : false; # VALUE		  $this->_format     = array_key_exists('FORMAT', $assets)  ? $assets['FORMAT']  : false; # VALUE		  		   # PROCESS THE TABLE NAME VARIABLES                   $this->PROCESS_TABLE_NAME();                                      # SELECT TYPE OF EXECUTION                  ($this->_table && ($this->_key || $this->_join)) ? $this->PROCESS_TABLE(): $this->SET_COLUMNS();                         		endif;	 }                          # FUNCTION NAME: PROCESS_TABLE_NAME        # PARAM        : THE TABLE        # DESCRIPTION  : THIS FUNCTION WILL PROCESS THE TABLE        private function PROCESS_TABLE_NAME($arrs=false){            $table_array = !$arrs ? $this->_table_raw : $arrs;             $_table = explode('::', $table_array);            $_return      =  isset($_table[1])&&$_table[1] ? $_table[0].' '.$_table[1] : $_table[0];            $this->_table =  $_table[0];                        return $_return;        }                  # FUNCTION NAME: PROCESS_JOIN_CLAUSE        # PARAM        : array to be processed        # DESCRIPTION  : THIS FUNCTION WILL PROCESS THE JOIN ARRAY         private function PROCESS_JOIN_CLAUSE($arrs = array()){         $str = '';            if(!isset($arrs[0])):             $join_type  = isset($arrs['TYPE']) ? $arrs['TYPE'] . ' JOIN ' : ' INNER JOIN ';             $join_table = $this->PROCESS_TABLE_NAME($arrs['TABLE']);             $join_on    = $arrs['ON'];             $str        = ' '.$join_type .  $join_table .' ON '. $join_on;          else:             foreach($arrs as $arr):             $join_type  = isset($arr['TYPE']) ? $arr['TYPE'] . ' JOIN ' : ' INNER JOIN ';             $join_table = $this->PROCESS_TABLE_NAME($arr['TABLE']);             $join_on    = $arr['ON'];             $str        .= ' '.$join_type .  $join_table .' ON '. $join_on;         endforeach;             endif;                   return $str;         }                 private function PROCESS_GROUP_BY_CLAUSE($clause){            $str = ' GROUP BY ' . $clause . ' ';            return $str;        } 	 	#FUNCTION NAME: PROCESS_COLUMNS_ARRAY	# PARAM       : array to be processed	# DESCRIPTION : THIS FUNCTION WILL PROCESS THE ARRAY AND CONVERT IT TO A STRING	#               TYPE OF POSSIBLE ARRAY PARAMS: 	#               REGULAR PARAM: array('ID','Name','Gender')                       	#               DYNAMIC PARAM FOR (CONCAT AS) KEYWORD : array('ID','Name'=>'FirstName,LastName','Gender') 	private function PROCESS_COLUMNS_ARRAY($arrs = array())	{         $str = '';        foreach($arrs as $key => $arr){                 $str .= !is_numeric($key) ? 'CONCAT('.$arr.') AS ' . $key . ',' : $arr .',';            } 	               return rtrim($str,',');	}		#FUNCTION NAME: PROCESS_KEYS_ARRAY	# PARAM       : array to be processed	# DESCRIPTION : THIS FUNCTION WILL PROCESS THE ARRAY AND CONVERT IT TO A STRING	#               TYPE OF POSSIBLE ARRAY PARAMS: 	#               REGULAR PARAM: array('ID','Name','Gender')                       	#               DYNAMIC PARAM FOR (CONCAT AS) KEYWORD : array('ID','Name'=>'FirstName,LastName','Gender') 	private function PROCESS_KEYS_ARRAY($arrs = array())	{          $str = ' WHERE ';	 if(!is_array($arrs) && $arrs):	    $str .= '1'; 		           else:             foreach($arrs as $key => $arr){                     $temp_key = explode('::', $key);                     $key_name = $temp_key[0];                     $process  = isset($temp_key[1])&&$temp_key[1]?$temp_key[1]:' = ';                     $str .= $key_name .' '.$process .' :' . $key_name . ' AND ';	     } 	 	 endif;         return rtrim($str,'AND ');	}                #FUNCTION NAME: CLEANUP_KEYS	# PARAM       : array to be processed	# DESCRIPTION : THIS FUNCTION WILL CLEANUP THE KEY ARRAY AND REMOVE THE :: CHARACTER (FOR INSERT, UPDATE QUERIES) 	#               TYPE OF POSSIBLE ARRAY PARAMS: 	#               REGULAR PARAM: array('ID','Name','Gender')                       	#               DYNAMIC PARAM FOR (CONCAT AS) KEYWORD : array('ID','Name'=>'FirstName,LastName','Gender')        private function CLEANUP_KEYS($arrs=array()){            $clean = array();            $keys  = $arrs;                       foreach($keys as $k => $v):                $_index =explode('::',$k);                 $clean[$_index[0]] = $v;             endforeach;                        return $clean;        }	        #FUNCTION NAME: PROCESS_ORDER	# PARAM       : NONE	# DESCRIPTION : THIS FUNCTION WILL PROCESS THE LIMIT CLAUSE BASED ON THE VALUE PASSED BY THE USER 	#               PARAM: 'LIMIT'=>'0,10' | 'LIMIT'=>'10'                       	private function PROCESS_ORDER()	{                $str=' ORDER BY ';                $_order = explode('::',  $this->_order);                $_by = isset($_order[1])?$_order[1]:'ASC';                  $str .= $_order[0].' '.$_by.' ' ; 		return $str; 	   		}        	#FUNCTION NAME: PROCESS_LIMIT_CLAUSE	# PARAM       : NONE	# DESCRIPTION : THIS FUNCTION WILL PROCESS THE LIMIT CLAUSE BASED ON THE VALUE PASSED BY THE USER 	#               PARAM: 'LIMIT'=>'0,10' | 'LIMIT'=>'10'                       	private function PROCESS_LIMIT_CLAUSE()	{		$str=' LIMIT ';		$str .= $this->_limit ? $this->_limit : ''; 		return $str; 	   		}		# DESCRIPTION : THIS FUNCTION DETECTS IF THE CLASS INSTANCE REQUIRES A SPECIFIC SET[S] OF COLUMN[S] IN THE TABLE AND LOADS THEM AUTOMATICALLY	#               FIRST IF{} BLOCK FETCHES SPECIFIC COLUMN[S] ELSE{} BLOCK SETS ALL COLUMN[S]	private function SET_COLUMNS()	{	 $this->_cols = is_array($this->_cols) ? $this->_cols : ($this->_cols ? explode(',',$this->_cols) : false); 	 if($this->_cols):	    foreach($this->_cols as $key => $col):		   $this->_columns[trim($key)] = trim($col);	            endforeach;	  else:                 $prepared = $this->_conn->prepare("SHOW COLUMNS FROM " .  $this->_table);		                 $prepared->execute();		while($row = $prepared->fetch()):                  $this->_columns[$row['Field']] = '';                endwhile;	  endif;	}   # DESCRIPTION : EXECUTES THE QUERY   private function PROCESS_TABLE()   {          # SET THE COLUMNS 	  $this->SET_COLUMNS();	   	  # PROCESS THE CLAUSES --------------------------------------------------------------------------------          $join    = $this->_join                          ? $this->PROCESS_JOIN_CLAUSE($this->_join)     :'';  # JOIN CLAUSE           $columns = $this->_cols                          ? $this->PROCESS_COLUMNS_ARRAY($this->_columns):'*'; # COLUMNS CLAUSE          $keys    = $this->_key                           ? $this->PROCESS_KEYS_ARRAY($this->_key)       :'';  # KEY CLAUSE           $sub     = $this->_sub && is_string($this->_sub) ? ' ' . $this->_sub . ' '                      :'';  # SUB_KEY ONLY IF KEY IS DEFINED	  $group   = $this->_group                         ? $this->PROCESS_GROUP_BY_CLAUSE($this->_group):'';  # GROUP CLAUSE          $order   = $this->_order                         ? $this->PROCESS_ORDER()                       :'';  # ORDER CLAUSE 	  $limit   = $this->_limit                         ? $this->PROCESS_LIMIT_CLAUSE()                :'';  # LIMIT CLAUSE	            # SET THE QUERY ---------------------------------------------------------------------------------------	  $query    = 'SELECT ' . $columns . ' FROM '. $this->PROCESS_TABLE_NAME() . $join . $keys . $sub . $group . $order . $limit;                     //echo $query . '<br />'; exit;          	  # ASSIGN QUERY STRING	  $this->_query_string = $query;	           	  # PREPARE THE QUERY	  $prepared = $this->_conn->prepare($query);	  	  # EXECUTE THE QUERY AND BIND THE KEY IF THERE IS A KEY PASSED 	  ((!is_array($this->_key) && $this->_key)  || ((!is_array($this->_key) && $this->_key) && $this->_join) || ($this->_join && !(is_array($this->_key) && $this->_key))  ) ? $prepared->execute() : $prepared->execute($this->CLEANUP_KEYS($this->_key));                # ^ WITHOUT A KEY                           ^ WITHOUT A KEY BUT WITH JOIN                                   ^ WITH JOIN AND WITH KEY 	                  # FETCH ALL RESULTS 	  $result   =  $prepared->fetchAll(PDO::FETCH_ASSOC); 	           	  foreach($result as $key => $values):		  foreach($values as $keyVal => $value):		     # FORMAT THE COLUMNS IF FORMATTING IS SPECIFIED                      if(is_array($this->_format) && in_array($keyVal,array_keys($this->_format))):                             $value = eval('return(' . $this->_format[$keyVal] .  ');');                     endif;                     $this->_result[$key][$keyVal] = trim($value); 		endforeach; 	  endforeach;                    # CREATE OBJECT ARRAY OF THE FIRST ROW          $this->fetch =  (object) $this->_result[0];         return $prepared;   }      private function EXECUTE_QUERY(){       # PREPARE THE QUERY	$prepared = $this->_conn->prepare($this->_query_string);                 # EXECUTE THE QUERY AND BIND THE KEY IF THERE IS A KEY PASSED 	  ((!is_array($this->_key) && $this->_key)  || ((!is_array($this->_key) && $this->_key) && $this->_join) || ($this->_join && !(is_array($this->_key) && $this->_key))  ) ? $prepared->execute() : $prepared->execute($this->CLEANUP_KEYS($this->_key));                # ^ WITHOUT A KEY                           ^ WITHOUT A KEY BUT WITH JOIN                                   ^ WITH JOIN AND WITH KEY 	return $prepared;     }      # PREPARES THE ARRAY BIND FOR THE PDO EXECUTE   private function PROCESS_DATA_SET($ARRS=array()){	   $str = '';	   if(!empty($ARRS)):	       foreach($ARRS as $key => $arr):			 $str .= str_replace($this->_modifier,'',$key) . '=:'. $key . ',';               endforeach;              endif;	   return rtrim($str,',');   }    		   private function INSERT_QUERY($ARRS = array()){			  $data = $this->PROCESS_DATA_SET($ARRS);		  $query    = 'INSERT INTO ' . $this->_table . ' SET ' . $data; 		 	  # ASSIGN QUERY STRING	  $this->_query_string = $query;	  	  # PREPARE THE QUERY	  $prepared = $this->_conn->prepare($query);          $result = $prepared->execute($ARRS);          return $result;    }	    private function UPDATE_QUERY($ARRS = array()){	 # NEED TO ALTER ARRAY TO PREVENT A POTENTIAL DUPLICATE ON THE KEYS AND THE COLUMNS TO BE MODIFIED	 $alterARRS = array();	 foreach($ARRS as $key => $val):			$alterARRS[$key.$this->_modifier] = $val;         endforeach;			# SET THE CLAUSES	$data = $this->PROCESS_DATA_SET($alterARRS);	$keys = $this->_key ? $this->PROCESS_KEYS_ARRAY($this->_key):'';	  	# MERGE THE VARIABLES	$bindARRs = array_merge($alterARRS,$this->_key);		# RUN THE QUERY 	$query = 'UPDATE ' . $this->_table . ' SET ' . $data . $keys;			# ASSIGN QUERY STRING	$this->_query_string = $query;			# PREPARE THE QUERY	$prepared = $this->_conn->prepare($query);			# BIND THE PARAMS 	$result = $prepared->execute($bindARRs);	return $result;     }                private function DELETE_QUERY(){            $result = false;            $keys = $this->_key ? ( is_array($this->_key) ? $this->PROCESS_KEYS_ARRAY($this->_key) : false )    : false;            if($keys):                $query = 'DELETE FROM ' . $this->_table . $keys;                $prepared = $this->_conn->prepare($query);                $result = $prepared->execute($this->_key);						$this->_query_string = $query;            endif;           return $result;        }		private function RUN_QUERY($clause,$params){		$query    = $clause;		$prepared = $this->_conn->prepare($query);		$prepared->execute($params);		return $prepared; 	}#----------------------------------------------------------------------------------------------------------------------------------------##-PUBLIC FUNCTIONS DEFINED  HERE---------------------------------------------------------------------------------------------------------#	#----------------------------------------------------------------------------------------------------------------------------------------#      public function fetch($key,$place=0){            $result = !empty($this->_result) ? $this->_result[$place][$key] :false;            return $result;		}        public function result(){            return $this->EXECUTE_QUERY();        }                   public function fetchRow($place=0){            $result = !empty($this->_result) ? $this->_result[$place] : false; //'NOTICE:  NO RESULT(S) FOUND';            return $result;        }        public function fetchAll(){            $result = !empty($this->_result) ? $this->_result : false; //'NOTICE: NO RESULT(S) FOUND';	    return $result;	        }			public function lastId(){		  	return $this->_conn->lastInsertId();       	}		public function save($data){	   $result =  $this->_key && is_array($this->_key) && !empty($this->_result) ?  $this->UPDATE_QUERY($data) : $this->INSERT_QUERY($data);    		   return $result;		}                public function delete(){            $result = $this->DELETE_QUERY();            return $result;        }        public function numRows(){            return count($this->_result);        }                	public function run($clause,$params=array()){	    return $this->RUN_QUERY($clause,$params);	}			public function showLastQuery(){	    return $this->_query_string ? $this->_query_string : false; 	}                public function pre($array){            echo'<pre>';            print_r($array);            echo'</pre>';        }        } // END CLASS?>